(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["autoComputeFirstScreenTime"] = factory();
	else
		root["autoComputeFirstScreenTime"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dot.js":
/*!****************!*\
  !*** ./dot.js ***!
  \****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 降级算法，该算法消耗一部分的性能，用于不支持 performance API 的场景，依赖 window.performance.timing\n\n// 脚本开始运行的时间，用于各种 log 等\nvar scriptStartTime = new Date().getTime();\n\nvar win = window;\nvar doc = win.document;\nvar util = __webpack_require__(/*! ./util */ \"./util.js\");\n\nvar acftGlobal = __webpack_require__(/*! ./global-info */ \"./global-info.js\");\n\nvar globalIndex = 0;\n\nfunction generateApi() {\n    var _global = util.mergeGlobal(util.initGlobal(), {\n        intervalDotTimer: null,\n\n        // 是否已经停止监听的标志\n        hasStoppedObserve: false,\n\n        // 打点数组\n        dotList: [],\n\n        // 记录图片加载完成的时刻（唯一）\n        imgMap: {},\n\n        // 打点间隔\n        dotDelay: 250,\n\n        abortTimeWhenDelay: 500 // 监控打点会引起页面重绘，如果引发页面重绘的时间超过了该值，则不再做性能统计\n    });\n\n    _global.globalIndex = 'dot-' + globalIndex++;\n\n    util.watchDomUpdate(_global);\n\n    function _getTargetDotObj() {\n        // 按照打点时刻倒序\n        _global.dotList.sort(function (a, b) {\n            if (a.dotTimeStamp < b.dotTimeStamp) {\n                return 1;\n            } else {\n                return -1;\n            }\n        });\n\n        var dotList = _global.dotList.slice(1);\n\n        // 获取当前时刻的 dom 信息，作为基准值\n        var finalImages = _global.dotList[0].firstScreenImages;\n\n        var targetInfo;\n\n        var isBiggerArray = function (bigArr, smallArr) {\n            for (var i = 0, len = smallArr.length; i < len; i++) {\n                if (bigArr.indexOf(smallArr[i]) === -1) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        // 如果最终状态的首屏有图片，则通过比较首屏图片数量来确定是否首屏加载完毕\n        if (finalImages.length > 0) {\n            for (var i = 0, len = dotList.length; i < len; i++) {\n                var item = dotList[i];\n                if (isBiggerArray(item.firstScreenImages, finalImages)) {\n                    targetInfo = dotList[i];\n                }\n            }\n\n            // 如果仍然没有找到 targetInfo，则取稳定状态的值\n            if (!targetInfo) {\n                targetInfo = _global.dotList[0];\n            }\n        } else {\n            // 如果最终状态没有图片，则取出当前打点的对象，首屏时间设置为 performance 值\n            targetInfo = _global.dotList[0];\n            targetInfo.firstScreenTimeStamp = performance.timing.domComplete; // 有 bug，过早获取时该值可能为 0\n            targetInfo.firstScreenTime = performance.timing.domComplete - _global.forcedNavStartTimeStamp;\n        }\n\n        return targetInfo;\n    }\n\n    // 只会执行一次\n    function _report(targetDotObj) {\n        var stableDotObj = _global.dotList[0];\n\n        var generateResultObj = function() {\n            // 为 _global.imgMap 添加是否是首屏标志\n            var targetFirstScreenImages = null;\n            var firstScreenImages = [];\n            var i;\n            var len;\n            var requests = [];\n\n            for (i = 0, len = _global.dotList.length; i < len; i++) {\n                if (_global.dotList[i].isTargetDot) {\n                    targetFirstScreenImages = _global.dotList[i].firstScreenImages;\n                    break;\n                }\n            }\n\n            if (targetFirstScreenImages) {\n                for (i = 0, len = targetFirstScreenImages.length; i < len; i++) {\n                    firstScreenImages.push(targetFirstScreenImages[i].replace(/^http(s)?:/, '').replace(/^\\/\\//, ''));\n                }\n            }\n\n            // 计算性能监控计算的耗时\n            var delayFirstScreen = 0;\n            for (i = 0, len = _global.dotList.length; i < len; i++) {\n                if (_global.dotList[i].delay) {\n                    if (_global.dotList[i].dotTimeStamp <= targetDotObj.dotTimeStamp) {\n                        delayFirstScreen += _global.dotList[i].delay;\n                    }\n                }\n            }\n\n            // 规范化 requests\n            for (var requestKey in _global.requestDetails) {\n                var parsedRequestKey = requestKey\n                    .split('>time')[0]\n                    .replace(/^http(s)?:/, '')\n                    .replace(/^\\/\\//, '');\n                requests.push(parsedRequestKey);\n            }\n\n            // 最终呈现给用户的首屏信息对象\n            var resultObj = {\n                success: true,\n                maxErrorTime: targetDotObj.maxErrorTime, // 最大误差值\n                dotList: _global.dotList, // 打点列表\n                isStaticPage: _global.isFirstRequestSent ? false : (/auto/.test(_global.reportDesc) ? true : 'unknown'), // 是否是静态页面（没有请求发出）\n                requests: util.transRequestDetails2Arr(_global), // 监控期间拦截的请求\n                firstScreenTime: targetDotObj.firstScreenTimeStamp - _global.forcedNavStartTimeStamp, // 首屏时长\n                firstScreenTimeStamp: targetDotObj.firstScreenTimeStamp, // 首屏结束的时刻\n                firstScreenImages: stableDotObj.firstScreenImages, // 首屏图片列表，必须使用稳定时刻的值\n                firstScreenImagesLength: stableDotObj.firstScreenImages.length, // 首屏图片数量，必须使用稳定时刻的值\n                firstScreenImagesDetail: targetDotObj.firstScreenImagesDetail, // 首屏图片细节，使用目标打点的数据\n                navigationStartTimeStamp: _global.forcedNavStartTimeStamp,\n                navigationStartTime: _global.forcedNavStartTimeStamp - _global._originalNavStart,\n                isOriginalNavStart: _global.forcedNavStartTimeStamp === _global._originalNavStart,\n                delayFirstScreen: delayFirstScreen, // 计算引发的首屏时间 delay\n                delayAll: _global.delayAll, // 计算引发的总 delay\n                type: 'dot',\n                version: util.version,\n                runtime: util.getTime() - scriptStartTime, // 检测脚本运行的时长\n                reportDesc: _global.reportDesc,\n                url: window.location.href.substring(0, 200), // 当前页面 url\n                ignoredImages: _global.ignoredImages, // 计算首屏时被忽略的图片\n                device: _global.device, // 当前设备信息\n                globalIndex: _global.globalIndex,\n                domChangeList: _global.domChangeList, // dom 变化数组\n                navigationTagChangeMap: acftGlobal.navigationTagChangeMap,\n                reportTimeFrom: targetDotObj.reportTimeFrom\n            };\n\n            return resultObj;\n        }\n\n        var canReport = function () {\n            // 如果退出上报，则直接返回\n            if (_global.hasReported) {\n                return false;\n            }\n\n            if (_global.abortReport) {\n                return false;\n            }\n\n            return true;\n        };\n\n        if (_global.abortByDelayTimeout) {\n            // 上报\n            _global.onReport({\n                success: false,\n                delayFirstScreen: _global.delayAll,\n                abortTimeSetting: _global.abortTimeWhenDelay,\n                url: window.location.href.substring(0, 200),\n                dotList: _global.dotList,\n                globalIndex: _global.globalIndex,\n                type: 'dot'\n            });\n            return;\n        }\n\n        var resultObj = generateResultObj();\n        \n        if (_global.delayReport) {\n            var timer = setTimeout(function () {\n                if (canReport()) {\n                    _global.onReport(resultObj);\n                    _global.hasReported = true;\n                }\n                \n                clearTimeout(timer);\n            }, _global.delayReport);\n        } else {\n            if (canReport()) {\n                _global.onReport(resultObj);\n                _global.hasReported = true;\n            }\n        }\n    }\n\n    // 记录运行该方法时刻的 dom 信息，主要是 images；运行时机为定时器触发\n    function recordDomInfo(param) {\n        var recordFirstScreen = param && param.recordFirstScreen;\n\n        // 如果在打点过程中，并且性能监控打点引发的渲染 delay 超过了设置的阈值，则停止性能监控打点\n        if (_global.delayAll >= _global.abortTimeWhenDelay) {\n            _global.abortByDelayTimeout = true;\n            return;\n        }\n\n        var recordStartTime = util.getTime();\n\n        var firstScreenImages = _getImages({ searchInFirstScreen: recordFirstScreen });\n\n        var recordEndTime = util.getTime();\n\n        _global.delayAll += recordEndTime - recordStartTime;\n\n        var dotObj = {\n            isImgInFirstScreen: recordFirstScreen || false,\n            isFromInternal: (param && param.isFromInternal) ? true : false,\n            firstScreenImages: firstScreenImages, // 此时打点的首屏图片数组\n            firstScreenImagesLength: firstScreenImages.length, // 有几张首屏图片\n            dotIndex: _global.dotList.length, // 打点索引\n            dotTimeStamp: recordStartTime, // 打点时刻\n            dotTimeDuration: recordStartTime - _global.forcedNavStartTimeStamp,\n            delay: recordEndTime - recordStartTime, // 此次打点持续了多久\n\n            // 标记该打点时刻抓到的图片是否全部 onload，后面会被修正\n            finished: false,\n\n            // 如果该打点是目标打点，下面各值会被修正\n            isTargetDot: (param && param.isTargetDot) || false, // 默认是 false, 除非手动设置是目标打点（用于手动埋点）\n            firstScreenTimeStamp: -1, // 当前时刻下，所有图片加载完毕的时刻\n            reportTimeFrom: '',\n            firstScreenImagesDetail: [],\n            maxErrorTime: 'unkown' // 误差值\n        };\n\n        _global.dotList.push(dotObj);\n\n        if (!firstScreenImages.length) {\n            dotObj.finished = true;\n        } else {\n            var imgIndex = 0;\n            var afterDownload = function (src) {\n                imgIndex++;\n\n                // 如果当前打点处，所有图片均已加载完毕，标记该打点已经完成\n                if (imgIndex === firstScreenImages.length) {\n                    dotObj.finished = true;\n                }\n            };\n\n            var generateGlobalImgMapResult = function (options) {\n                var time = util.getTime();\n                return {\n                    loadTimeStamp: time,\n                    loadDuration: time - _global.forcedNavStartTimeStamp,\n                    maxErrorTime: options.maxErrorTime,\n                    type: options.type\n                }\n            };\n\n            firstScreenImages.forEach(function (src) {\n                if (_global.imgMap[src]) {\n                    afterDownload(src);\n                } else {\n                    var img = new Image();\n                    img.src = util.formateUrlByAdd(src);\n\n                    if (img.complete) {\n                        // 记录该图片加载完成的时间，以最早那次为准\n                        if (!_global.imgMap[src]) {\n                            var currentImgMaxErrorTime = _global.dotList[dotObj.dotIndex - 1] ? (dotObj.dotTimeStamp - _global.dotList[dotObj.dotIndex - 1].dotTimeStamp) : 0;\n                            _global.imgMap[src] = generateGlobalImgMapResult({\n                                maxErrorTime: currentImgMaxErrorTime, \n                                type: 'complete'\n                            });\n                        }\n                        afterDownload(src);\n                    } else {\n                        img.onload = img.onerror = function () {\n                            // 记录该图片加载完成的时间，以最早那次为准\n                            if (!_global.imgMap[src]) {\n                                _global.imgMap[src] = generateGlobalImgMapResult({\n                                    maxErrorTime: 0,\n                                    type: 'onload'\n                                });\n                            }\n                            afterDownload(src);\n                        };\n                    }\n                }\n            });\n        }\n    }\n\n    function _getImages(param) {\n        var screenHeight = win.innerHeight;\n        var screenWidth = win.innerWidth;\n\n        if (!_global.device.screenWidth) {\n            _global.device.screenWidth = screenWidth;\n        }\n        if (!_global.device.screenHeight) {\n            _global.device.screenHeight = screenHeight;\n        }\n\n        var searchInFirstScreen = param && param.searchInFirstScreen;\n\n        var nodeIterator = util.queryAllNode(_global.ignoreTag);\n        var currentNode = nodeIterator.nextNode();\n        var imgList = [];\n\n        var onImgSrcFound = function(imgSrc) {\n            var protocol = util.parseUrl(imgSrc).protocol;\n            if (protocol && protocol.indexOf('http') === 0) {\n                // 去重\n                if (imgList.indexOf(imgSrc) === -1) {\n                    imgList.push(imgSrc);\n                }\n            }\n        }\n\n        // 遍历所有 dom\n        while (currentNode) {\n            var imgSrc = util.getImgSrcFromDom(currentNode, _global.img);\n\n            // 如果没有 imgSrc，则直接读取下一个 dom 的信息\n            if (!imgSrc) {\n                currentNode = nodeIterator.nextNode();\n                continue;\n            }\n\n            if (searchInFirstScreen) {\n                util.recordCurrentPos(currentNode, _global);\n\n                if (util.isInFirstScreen(currentNode)) {\n                    onImgSrcFound(imgSrc);\n                } else {\n                    var currentPos = util.currentPos;\n                    // 用于统计\n                    _global.ignoredImages.push({\n                        src: imgSrc,\n                        screenHeight: screenHeight,\n                        screenWidth: screenWidth,\n                        scrollTop: currentPos.scrollTop,\n                        top: currentPos.top,\n                        bottom: currentPos.bottom,\n                        vertical: (currentPos.scrollTop + currentPos.top) <= screenHeight,\n                        left: currentPos.left,\n                        right: currentPos.right,\n                        horizontal: currentPos.right >= 0 && currentPos.left <= screenWidth\n                    });\n                }\n            } else {\n                onImgSrcFound(imgSrc);\n            }\n            \n            currentNode = nodeIterator.nextNode();\n        }\n\n        return imgList;\n    }\n\n    function onStopObserving() {\n        if (_global.hasStoppedObserve) {\n            return;\n        }\n\n        _global.hasStoppedObserve = true;\n\n        // 标记停止监听请求\n        _global.stopCatchingRequest = true;\n\n        util.stopWatchDomUpdate(_global);\n        util.stopCatchingRequest(_global);\n\n        clearInterval(_global.intervalDotTimer);\n\n        // 记录当前时刻 dom 信息，且当前时刻为首屏图片数量等稳定的时刻\n        recordDomInfo({ recordFirstScreen: true });\n\n        // 向前递推，找到离稳定状态最近的打点对象\n        var targetDotObj = _getTargetDotObj(_global.dotList);\n\n        _global.onStableStatusFound(targetDotObj);\n\n        targetDotObj.isTargetDot = true;\n\n        // 触发事件：所有异步请求已经发布完毕\n        _global.onAllXhrResolved && _global.onAllXhrResolved(targetDotObj.dotTimeStamp);\n\n        // 如果 target 时刻的图片已经加载完毕，则上报该信息中记录的完成时刻\n        var checkTimer = null;\n        var check = function () {\n            if (targetDotObj.finished) {\n                reportTargetDotObj(targetDotObj);\n                clearInterval(checkTimer);\n\n                // clear todo\n            }\n        };\n        checkTimer = setInterval(check, 1000);\n        check();\n    }\n\n    // 此时所有图片均已 onload\n    function reportTargetDotObj(targetDotObj) {\n        var stableDotObj = _global.dotList[0];\n\n        var _getFirstScreenImageDetailsFromDot = function() {\n            var firstScreenImagesDetail = [];\n            var firstScreenImages = stableDotObj.firstScreenImages; // 首屏图片，必须使用稳定时刻的值\n\n            for (var i = 0, len = firstScreenImages.length; i < len; i++) {\n                var imgMapKey = firstScreenImages[i];\n                var imgItem = _global.imgMap[imgMapKey];\n                if (imgItem) {\n                    firstScreenImagesDetail.push({\n                        src: imgMapKey,\n                        type: imgItem['type'],\n                        maxErrorTime: imgItem['maxErrorTime'],\n                        loadTimeStamp: imgItem['loadTimeStamp'],\n                        loadDuration: imgItem['loadDuration'],\n                        from: 'dot'\n                    });\n                }\n            }\n\n            firstScreenImagesDetail.sort(function (a, b) {\n                return b.loadDuration - a.loadDuration;\n            });\n\n            return firstScreenImagesDetail;\n        }\n        var whenNoImages = function() {\n            if (/^hand/.test(_global.reportDesc)) {\n                targetDotObj.firstScreenTimeStamp = _global.handExcuteTime;\n                targetDotObj.reportTimeFrom = 'dot-hand-from-force';\n                targetDotObj.firstScreenImagesDetail = _getFirstScreenImageDetailsFromDot();\n                _report(targetDotObj);\n            } else {\n                util.getDomReadyTime(_global, function (domReadyTimeStamp, reportTimeFrom) {\n                    targetDotObj.firstScreenTimeStamp = domReadyTimeStamp;\n                    targetDotObj.reportTimeFrom = reportTimeFrom;\n                    targetDotObj.firstScreenImagesDetail = _getFirstScreenImageDetailsFromDot();\n                    _report(targetDotObj);\n                });\n            }\n        };\n\n        var whenHasImages = function() {\n            var _getLastImgDownloadDetailFromDot = function(images) {\n                var timeArr = [];\n\n                images.forEach(function (src) {\n                    timeArr.push(_global.imgMap[src]);\n                });\n\n                // 倒序\n                timeArr.sort(function (a, b) {\n                    if (a.loadTimeStamp < b.loadTimeStamp) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                });\n\n                return timeArr[0];\n            };\n\n            var generateResultFromDot = function (reportTimeFrom) {\n                var lastImgDownloadDetail = _getLastImgDownloadDetailFromDot(stableDotObj.firstScreenImages);\n                targetDotObj.firstScreenTimeStamp = lastImgDownloadDetail.loadTimeStamp; // 获取此次打点最后一张图片 onload 的时刻\n                targetDotObj.maxErrorTime = lastImgDownloadDetail.maxErrorTime; // 获取此次打点时最后一张图片 onload 时间的误差值\n                targetDotObj.reportTimeFrom = reportTimeFrom;\n                targetDotObj.firstScreenImagesDetail = _getFirstScreenImageDetailsFromDot();\n                _report(targetDotObj);\n            };\n\n            // 如果支持 performance API，则从 performance 中获取图片真实的返回时间\n            if (acftGlobal.supportPerformance) {\n                var isLastImageTimeFromOnload = function () {\n                    var lastImgDownloadDetail = _getLastImgDownloadDetailFromDot(stableDotObj.firstScreenImages);\n                    if (lastImgDownloadDetail && lastImgDownloadDetail.type === 'onload') {\n                        return true;\n                    }\n                    return false;\n                };\n\n                // 如果图片全部是通过 onload 获取的时间，优先从打点信息中；否则从 performance 数据取\n                if (isLastImageTimeFromOnload()) {\n                    generateResultFromDot('dot-img-from-onload');\n                } else {\n                    util.cycleGettingPerformaceTime(_global, stableDotObj.firstScreenImages, function (performanceResult) {\n                        targetDotObj.firstScreenImagesDetail = performanceResult.firstScreenImagesDetail;\n\n                        // 如果图片在上一个页面已经加载完毕，则还是通过打点记录的 onload 时间作为首屏时间\n                        if (performanceResult.firstScreenTimeStamp <= _global.forcedNavStartTimeStamp) {\n                            generateResultFromDot('dot-img-from-prepage-load');\n                        } else {\n                            // 如果图片在当前页面加载完毕，则通过 performance 获取首屏时间\n                            targetDotObj.firstScreenTimeStamp = performanceResult.firstScreenTimeStamp;\n                            targetDotObj.maxErrorTime = 0;\n                            targetDotObj.reportTimeFrom = 'dot-img-from-performance';\n                            _report(targetDotObj);\n                        }\n                    });\n                }\n            } else { // 如果不支持 performance API，则从打点信息中获取图片返回时间\n                generateResultFromDot('dot-img-from-onload');\n            }\n        };\n\n        if (targetDotObj.firstScreenImages.length === 0) {\n            whenNoImages();\n        } else {\n            whenHasImages();\n        }\n    }\n\n    // 插入脚本，用于获取脚本运行完成时间，这个时间用于获取当前页面是否有异步请求发出\n    function testStaticPage() {\n        util.testStaticPage(function() {\n            onStopObserving('dot-timeout');\n        }, _global);\n    }\n\n    // 监听 dom 变化，脚本运行时就开始\n    function observeDomChange() {\n        var lastObserverRunTime;\n\n        var dotCallback = function (param) {\n            var now = util.getTime();\n            if (lastObserverRunTime && now - lastObserverRunTime < _global.dotDelay) {\n                return;\n            }\n\n            lastObserverRunTime = now;\n\n            recordDomInfo(param);\n        };\n\n        // 记录首屏 DOM 的变化\n        _global.intervalDotTimer = setInterval(function () {\n            dotCallback({ isFromInternal: true });\n        }, _global.dotDelay);\n\n        // 触发回调前，先记录初始时刻的 dom 信息\n        dotCallback();\n    }\n\n    function overrideRequest() {\n        util.overrideRequest(_global, function () {\n            onStopObserving('dot-request-end');\n        });\n    }\n\n    function mergeUserConfig(userConfig) {\n        util.mergeUserConfig(_global, userConfig);\n    }\n\n    return {\n        mergeUserConfig: mergeUserConfig,\n        testStaticPage: testStaticPage,\n        observeDomChange: observeDomChange,\n        overrideRequest: overrideRequest,\n        recordDomInfo: recordDomInfo,\n        onStopObserving: onStopObserving,\n        global: _global\n    };\n}\n\nmodule.exports = {\n    auto: function(userConfig) {\n        var go = function () {\n            var api = generateApi();\n            api.global.reportDesc = 'auto-dot';\n            api.mergeUserConfig(userConfig);\n            api.testStaticPage();\n            api.observeDomChange();\n            api.overrideRequest();\n            return api;\n        };\n\n        var api = go();\n\n        var preGlobal = api.global;\n        util.onNavigationStartChange(api.global, function (changeInfo) {\n            preGlobal.abortReport = true;\n\n            // 触发用户注册的回调\n            preGlobal.onNavigationStartChange(changeInfo);\n\n            // 下次启动首屏时间计算，设置 navStart 的时刻\n            userConfig.forcedNavStartTimeStamp = changeInfo.timeStamp;\n\n            // 重新运行首屏时间计算，需要使用 dot 的方式\n            preGlobal = go().global;\n        });\n\n        return api.global;\n    },\n    hand: function(userConfig) {\n        var api = generateApi();\n        api.global.reportDesc = 'hand-dot';\n        api.global.handExcuteTime = new Date().getTime();\n        api.mergeUserConfig(userConfig);\n        api.onStopObserving();\n    }\n};\n\n\n\n//# sourceURL=webpack://autoComputeFirstScreenTime/./dot.js?");

/***/ }),

/***/ "./global-info.js":
/*!************************!*\
  !*** ./global-info.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n    watchingNavStartChange: false,\n    navigationTagChangeMap: {\n        realChangeList: [],\n        usedChangeList: []\n    },\n    onloadFinished: false,\n    supportPerformance: ('performance' in window) && ('getEntriesByType' in window.performance) && (window.performance.getEntriesByType('resource') instanceof Array)\n};\n\n//# sourceURL=webpack://autoComputeFirstScreenTime/./global-info.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @description compute first screen time of one page with inaccuracy less than 250ms\n * @author 刘远洋 https://github.com/hoperyy\n * @date 2018/02/22\n */\n\nvar supportQuerySelector = !!document.querySelector;\nvar supportPerformance = ('performance' in window) && ('getEntriesByType' in window.performance) && (window.performance.getEntriesByType('resource') instanceof Array);\nvar supportTiming = window.performance && window.performance.timing;\n\nvar noop = function() {};\n\n// 强制使用打点方式获取首屏时间\n// supportPerformance = false;\n\nfunction getRandom() {\n    var random = document.body.getAttribute('perf-random');\n\n    if (typeof random === 'object' && random === null) {\n        random = 1;\n    }\n\n    if (typeof random === 'string') {\n        if (random.replace(/\\s*/, '')) {\n            random = parseFloat(random);\n        } else {\n            random = 1; // blank string\n        }\n    }\n\n    // backup\n    if (!random && random !== 0) {\n        random = 1;\n    }\n\n    if (random > 1) {\n        random = 1;\n    }\n\n    if (random < 0) {\n        random = 0;\n    }\n\n    return random;\n}\n\nif (supportQuerySelector) {\n    var forceDot = document.querySelector('[perf-dot]') === document.body;\n\n    if (Math.random() > getRandom()) {\n        module.exports = noop;\n        module.exports.report = noop;\n    } else {\n        if (forceDot) {\n            if (supportTiming) {\n                module.exports = __webpack_require__(/*! ./dot */ \"./dot.js\").auto;\n                module.exports.report = __webpack_require__(/*! ./dot */ \"./dot.js\").hand;\n            } else {\n                module.exports = noop;\n                module.exports.report = noop;\n            }\n        } else {\n            if (supportPerformance) {\n                module.exports = __webpack_require__(/*! ./perf */ \"./perf.js\").auto;\n                module.exports.report = __webpack_require__(/*! ./perf */ \"./perf.js\").hand;\n            } else if (supportTiming) {\n                module.exports = __webpack_require__(/*! ./dot */ \"./dot.js\").auto;\n                module.exports.report = __webpack_require__(/*! ./dot */ \"./dot.js\").hand;\n            } else {\n                module.exports = noop;\n                module.exports.report = noop;\n            }\n        }\n    }\n} else {\n    module.exports = noop;\n    module.exports.report = noop;\n}\n\n\n//# sourceURL=webpack://autoComputeFirstScreenTime/./index.js?");

/***/ }),

/***/ "./perf.js":
/*!*****************!*\
  !*** ./perf.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 脚本开始运行的时间，用于各种 log 等\nvar scriptStartTime = new Date().getTime();\n\nvar win = window;\nvar doc = win.document;\nvar util = __webpack_require__(/*! ./util */ \"./util.js\");\n\nvar acftGlobal = __webpack_require__(/*! ./global-info */ \"./global-info.js\");\n\nvar globalIndex = 0;\n\nfunction generateApi() {\n\n    // 所有变量和函数定义在闭包环境，为了支持同时手动上报和自动上报功能\n    var _global = util.mergeGlobal(util.initGlobal(), {\n        hasStableFound: false\n    });\n\n    _global.globalIndex = 'perf-' + globalIndex++;\n\n    util.watchDomUpdate(_global);\n\n    function runOnPageStable() {\n        // 标记稳定时刻已经找到\n        if (_global.hasStableFound) {\n            return;\n        }\n\n        util.stopWatchDomUpdate(_global);\n        util.stopCatchingRequest(_global);\n\n        _global.hasStableFound = true;\n\n        // 标记停止监听请求\n        _global.stopCatchingRequest = true;\n\n        // 获取当前时刻获取的首屏信息，并根据该信息获取首屏时间\n        var stableObject = recordFirstScreenInfo();\n\n        // 触发用户注册的回调\n        _global.onStableStatusFound(stableObject);\n    }\n\n    function _report(resultObj) {\n        var canReport = function() {\n            // 如果退出上报，则直接返回\n            if (_global.hasReported) {\n                return false;\n            }\n\n            if (_global.abortReport) {\n                return false;\n            }\n\n            return true;\n        };\n\n        // 为 resultObj 添加 _global.ignoredImages 字段\n        resultObj.ignoredImages = _global.ignoredImages;\n        resultObj.device = _global.device;\n        resultObj.success = true;\n\n        if (_global.delayReport) {\n            var timer = setTimeout(function() {\n                if (canReport()) {\n                    _global.hasReported = true;\n                    _global.onReport(resultObj); // 上报的内容是定时器之前的数据\n                }\n                \n                clearTimeout(timer);\n            }, _global.delayReport);\n        } else {\n            if (canReport()) {\n                _global.onReport(resultObj);\n            }\n        }\n    }\n \n    // 重操作：记录运行该方法时刻的 dom 信息，主要是 images\n    function recordFirstScreenInfo() {\n        var startTime =  util.getTime();\n        var firstScreenImages = _getImagesInFirstScreen();\n        var endTime = util.getTime();\n        var firstScreenImagesDetail = [];\n\n        // 找到最后一个图片加载完成的时刻，作为首屏时刻\n        // 最终呈现给用户的首屏信息对象\n        var resultObj = {\n            type: 'perf',\n            isStaticPage: _global.isFirstRequestSent ? false : (/auto/.test(_global.reportDesc) ? true : 'unknown'),\n            firstScreenImages: [],\n            firstScreenImagesLength: 0,\n            firstScreenImagesDetail: firstScreenImagesDetail,\n            requests: util.transRequestDetails2Arr(_global),\n            delayAll: endTime - startTime,\n            delayFirstScreen: endTime - startTime,\n            firstScreenTime: -1, // 需要被覆盖的\n            firstScreenTimeStamp: -1, // 需要被覆盖的\n            maxErrorTime: 0,\n            navigationStartTimeStamp: _global.forcedNavStartTimeStamp,\n            navigationStartTime: _global.forcedNavStartTimeStamp - _global._originalNavStart,\n            isOriginalNavStart: _global.forcedNavStartTimeStamp === _global._originalNavStart,\n            version: util.version,\n            runtime: util.getTime() - scriptStartTime,\n            reportDesc: _global.reportDesc,\n            url: window.location.href.substring(0, 200),\n            globalIndex: _global.globalIndex,\n            domChangeList: _global.domChangeList,\n            navigationTagChangeMap: acftGlobal.navigationTagChangeMap,\n            reportTimeFrom: _global.reportTimeFrom // init，后面还会被赋值\n        };\n\n        var processNoImages = function() {\n            if (/^hand/.test(_global.reportDesc)) {\n                resultObj.firstScreenTimeStamp = _global.handExcuteTime;\n                resultObj.firstScreenTime = _global.handExcuteTime - _global._originalNavStart;\n\n                resultObj.reportTimeFrom = 'perf-hand-from-force';\n                _report(resultObj);\n            } else {\n                util.getDomReadyTime(_global, function (domReadyTimeStamp, reportTimeFrom) {\n                    resultObj.firstScreenTimeStamp = domReadyTimeStamp;\n                    resultObj.firstScreenTime = domReadyTimeStamp - _global._originalNavStart;\n                    resultObj.reportTimeFrom = reportTimeFrom;\n                    _report(resultObj);\n                });\n            }\n        };\n\n        resultObj.firstScreenImages = firstScreenImages;\n        resultObj.firstScreenImagesLength = firstScreenImages.length;\n\n        if (!firstScreenImages.length) {\n            processNoImages();\n        } else {\n            util.getByOnload(_global, firstScreenImages, function (imgOnLoadResult) {\n                resultObj.firstScreenTime = imgOnLoadResult.firstScreenTime;\n                resultObj.firstScreenTimeStamp = imgOnLoadResult.firstScreenTimeStamp;\n                resultObj.firstScreenImagesDetail = imgOnLoadResult.firstScreenImagesDetail;\n                resultObj.reportTimeFrom = 'perf-img-from-onload';\n                _report(resultObj);\n            }, function() {\n                util.cycleGettingPerformaceTime(_global, firstScreenImages, function (performanceResult) {\n                    resultObj.firstScreenTime = performanceResult.firstScreenTime;\n                    resultObj.firstScreenTimeStamp = performanceResult.firstScreenTimeStamp;\n                    resultObj.firstScreenImagesDetail = performanceResult.firstScreenImagesDetail;\n                    resultObj.reportTimeFrom = 'perf-img-from-performance';\n                    _report(resultObj);\n                });\n            });\n        }\n\n        return resultObj;\n    }\n\n    function _getImagesInFirstScreen() {\n        var screenHeight = win.innerHeight;\n        var screenWidth = win.innerWidth;\n\n        // 写入设备信息，用于上报（这里只会执行一次）\n        _global.device.screenHeight = screenHeight;\n        _global.device.screenWidth = screenWidth;\n\n        var nodeIterator = util.queryAllNode(_global.ignoreTag);\n        var currentNode = nodeIterator.nextNode();\n        var imgList = [];\n\n        var onImgSrcFound = function (imgSrc) {\n            var protocol = util.parseUrl(imgSrc).protocol;\n            if (protocol && protocol.indexOf('http') === 0) {\n                // 去重\n                if (imgList.indexOf(imgSrc) === -1) {\n                    imgList.push(imgSrc);\n                }\n            }\n        }\n\n        while (currentNode) {\n            var imgSrc = util.getImgSrcFromDom(currentNode, _global.img);\n\n            if (!imgSrc) {\n                currentNode = nodeIterator.nextNode();\n                continue;\n            }\n\n            util.recordCurrentPos(currentNode, _global);\n\n            if (util.isInFirstScreen(currentNode)) {\n                onImgSrcFound(imgSrc);\n            } else {\n                var currentPos = util.currentPos;\n                // 统计没有在首屏的图片信息\n                _global.ignoredImages.push({\n                    src: imgSrc,\n                    screenHeight: screenHeight,\n                    screenWidth: screenWidth,\n                    scrollTop: currentPos.scrollTop,\n                    top: currentPos.top,\n                    bottom: currentPos.bottom,\n                    vertical: (currentPos.scrollTop + currentPos.top) <= screenHeight,\n                    left: currentPos.left,\n                    right: currentPos.right,\n                    horizontal: currentPos.right >= 0 && currentPos.left <= screenWidth\n                });\n            }\n\n            currentNode = nodeIterator.nextNode();\n        }\n\n        return imgList;\n    }\n\n    // 插入脚本，用于获取脚本运行完成时间，这个时间用于获取当前页面是否有异步请求发出\n    function testStaticPage() {\n        util.testStaticPage(function() {\n            runOnPageStable('perf-auto-timeout');   \n        }, _global);\n    }\n\n    function overrideRequest() {\n        util.overrideRequest(_global, function () {\n            runOnPageStable('perf-auto-request-end');\n        });\n    }\n\n    function mergeUserConfig(userConfig) {\n        util.mergeUserConfig(_global, userConfig);\n    }\n\n    return {\n        mergeUserConfig: mergeUserConfig,\n        testStaticPage: testStaticPage,\n        overrideRequest: overrideRequest,\n        recordFirstScreenInfo: recordFirstScreenInfo,\n        global: _global\n    };\n}\n\nmodule.exports = {\n    auto: function (userConfig) {\n        var go = function () {\n            var api = generateApi('auto');\n            api.global.reportDesc = 'auto-perf';\n            api.mergeUserConfig(userConfig);\n            api.testStaticPage();\n            api.overrideRequest();\n            return api;\n        };\n\n        var api = go();\n\n        // 针对单页应用处理\n        var preGlobal = api.global;\n        util.onNavigationStartChange(api.global, function (changeInfo) {\n            preGlobal.abortReport = true;\n\n            // 触发用户注册的回调\n            preGlobal.onNavigationStartChange(changeInfo);\n\n            // 下次启动首屏时间计算，设置 navStart 的时刻\n            userConfig.forcedNavStartTimeStamp = changeInfo.timeStamp;\n\n            // 重新运行首屏时间计算，但需要使用 dot 的方式\n            preGlobal = __webpack_require__(/*! ./dot */ \"./dot.js\").auto(userConfig);\n        });\n\n        return api.global;\n    },\n    hand: function (userConfig) {\n        var api = generateApi('hand');\n        api.global.reportDesc = 'hand-perf';\n        api.global.handExcuteTime = new Date().getTime();\n        api.mergeUserConfig(userConfig);\n        api.recordFirstScreenInfo('perf-hand');\n    }\n}\n\n\n//# sourceURL=webpack://autoComputeFirstScreenTime/./perf.js?");

/***/ }),

/***/ "./util.js":
/*!*****************!*\
  !*** ./util.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n\nvar acftGlobal = __webpack_require__(/*! ./global-info */ \"./global-info.js\");\n\nvar SLICE = Array.prototype.slice;\n\nmodule.exports = {\n    version: '5.4.2',\n\n    getDomReadyTime: function (_global, callback) {\n        if (_global._isUsingOriginalNavStart) {\n            var count = 0;\n            var handler = function () {\n                if (performance.timing.domContentLoadedEventStart != 0) {\n                    callback(performance.timing.domContentLoadedEventStart, 'domContentLoadedEventStart');\n                }\n\n                if (++count >= 50 || performance.timing.domContentLoadedEventStart != 0) {\n                    clearInterval(timer);\n                }\n            };\n            // 轮询获取 domComplete 的值，最多轮询 10 次\n            var timer = setInterval(handler, 500);\n\n            handler();   \n        } else {\n            if (_global.domUpdateTimeStamp) {\n                callback(_global.domUpdateTimeStamp, 'domUpdateTimeStamp');\n            } else {\n                callback(_global.forcedNavStartTimeStamp, 'forcedNavStartTimeStamp');\n            }\n        }\n    },\n\n    getImgSrcFromDom: function (dom, imgFilter) {\n        var src;\n\n        if (dom.nodeName.toUpperCase() == 'IMG') {\n            src = dom.getAttribute('src');\n        } else {\n            var computedStyle = window.getComputedStyle(dom);\n            var bgImg = computedStyle.getPropertyValue('background-image') || computedStyle.getPropertyValue('background');\n\n            var match = bgImg.match(/url\\(.+\\)/);\n            var str = match && match[0];\n            if (str) {\n                str = str.replace(/^url\\([\\'\\\"]?/, '').replace(/[\\'\\\"]?\\)$/, '');\n\n                if ((/^http/.test(str) || /^\\/\\//.test(str)) && this._filteImg(str, imgFilter)) {\n                    src = str;\n                }\n            }\n        }\n\n        return src;\n    },\n\n    _filteImg: function (src, imgFilter) {\n        for (var i = 0, len = imgFilter.length; i < len; i++) {\n            if (imgFilter[i].test(src)) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    currentPos: {\n        scrollTop: 0,\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0\n    },\n\n    recordCurrentPos: function (currentNode, _global) {\n        var boundingClientRect = currentNode.getBoundingClientRect();\n\n        var scrollWrapper = document.querySelector(_global.scrollWrapper);\n        var scrollTop;\n\n        // 优先使用加了 perf-scroll 标志的 dom 节点作为滚动容器\n        if (scrollWrapper) {\n            var scrollWrapperClientRect = scrollWrapper.getBoundingClientRect();\n\n            if (scrollWrapperClientRect.top < 0) {\n                scrollTop = -scrollWrapperClientRect.top;\n            } else {\n                scrollTop = 0;\n            }\n        } else {\n            scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        }\n\n        var top = boundingClientRect.top; // getBoundingClientRect 会引起重绘\n        var bottom = boundingClientRect.bottom;\n        var left = boundingClientRect.left;\n        var right = boundingClientRect.right;\n\n        this.currentPos.scrollTop = scrollTop;\n        this.currentPos.top = top;\n        this.currentPos.bottom = bottom;\n        this.currentPos.left = left;\n        this.currentPos.right = right;\n    },\n\n    isInFirstScreen: function (currentNode) {\n        // 如果已不显示（display: none），top 和 bottom 均为 0\n        if (!this.currentPos.top && !this.currentPos.bottom) {\n            return false;\n        }\n\n        var screenHeight = window.innerHeight;\n        var screenWidth = window.innerWidth;\n\n        var scrollTop = this.currentPos.scrollTop;\n        var top = this.currentPos.top;\n        var left = this.currentPos.left;\n        var right = this.currentPos.right;\n\n        // 如果在结构上的首屏内（上下、左右）\n        if ((scrollTop + top) < screenHeight && right > 0 && left < screenWidth) {\n            return true;\n        }\n\n        return false;\n    },\n    queryAllNode: function (ignoreTag) {\n        var _this = this;\n\n        var result = document.createNodeIterator(\n            document.body,\n            NodeFilter.SHOW_ELEMENT,\n            function (node) {\n                // 判断该元素及其父元素是否是需要忽略的元素\n                if (!_this._shouldIgnoreNode(node, ignoreTag)) {\n                    return NodeFilter.FILTER_ACCEPT;\n                }\n            }\n        );\n\n        return result;\n    },\n    _shouldIgnoreNode: function (child, ignoreTag) {\n        var ignoredNodes = document.querySelectorAll(ignoreTag);\n\n        for (var i = 0, len = ignoredNodes.length; i < len; i++) {\n            if (this._isChild(child, ignoredNodes[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    _isChild: function (child, parent) {\n        var isChild = false;\n\n        while (child) {\n            if (child === parent) {\n                isChild = true;\n                break;\n            }\n\n            child = child.parentNode;\n        }\n\n        return isChild;\n    },\n    parseUrl: function (url) {\n        var anchor = document.createElement('a');\n        anchor.href = url;\n        return anchor;\n    },\n    transRequestDetails2Arr: function (_global) {\n        var requests = [];\n        var requestItem = {};\n\n        // 规范化 requests\n        for (var requestDetailKey in _global.requestDetails) {\n            var parsedRequestDetailKey = requestDetailKey\n                .split(\">time\")[0]\n                .replace(/^http(s)?:/, '')\n                .replace(/^\\/\\//, '');\n\n            requestItem = {\n                src: parsedRequestDetailKey\n            };\n\n            for (var requestItemkey in _global.requestDetails[requestDetailKey]) {\n                requestItem[requestItemkey] = _global.requestDetails[requestDetailKey][requestItemkey];\n            }\n\n            requests.push(requestItem);\n        }\n\n        return requests;\n    },\n\n    formateUrlByRemove: function (url) {\n        return url.replace(/^http(s)?\\:/, '').replace(/^\\/\\//, '');\n    },\n\n    formateUrlByAdd: function (url) {\n        if (/^http/.test(url)) {\n            return url;\n        }\n\n        if (/^\\/\\//.test(url)) {\n            return window.location.protocol + url;\n        }\n\n        return window.location.protocol + '//' + url;\n    },\n\n    initGlobal: function () {\n        return {\n            // 是否已经上报的标志\n            stopCatchingRequest: false,\n\n            // 是否抓取过请求的标志位\n            isFirstRequestSent: false,\n\n            // 可以抓取请求的时间窗口队列\n            catchRequestTimeSections: [],\n\n            // 统计没有被计入首屏的图片有哪些，和更详细的信息\n            ignoredImages: [],\n\n            // 设备信息，用于样本分析\n            device: {},\n\n            requestDetails: {},\n\n            delayAll: 0,\n\n            ignoreTag: '[perf-ignore]',\n\n            scrollWrapper: '[perf-scroll]',\n\n            // 记录 url 改变的历史，用于单页应用性能监控\n            urlChangeStore: [],\n\n            // 是否已经上报\n            hasReported: false,\n\n            // 描述上报类型，默认是空\n            reportDesc: '',\n\n            // 记录 dom 更新的时间\n            domUpdateTimeStamp: 0,\n\n            // 手动上报运行的时刻\n            handExcuteTime: 0,\n\n            // 计算首屏时间耗时的开始时刻，默认是 navigationStart，对于单页应用，该值有可能修改\n            forcedNavStartTimeStamp: window.performance.timing.navigationStart,\n\n            _originalNavStart: window.performance.timing.navigationStart,\n\n            _isUsingOriginalNavStart: true,\n\n            abortReport: false,\n\n            onReport: function () { },\n\n            onStableStatusFound: function () { },\n\n            onNavigationStartChange: function() {},\n\n            request: {\n                limitedIn: [],\n                exclude: [/(sockjs)|(socketjs)|(socket\\.io)/]\n            },\n\n            // 获取数据后，认为渲染 dom 的时长；同时也是串联请求的等待间隔\n            renderTimeAfterGettingData: 500,\n\n            // onload 之后延时一段时间，如果到期后仍然没有异步请求发出，则认为是纯静态页面\n            watingTimeWhenDefineStaticPage: 2000,\n\n            img: [/(\\.)(png|jpg|jpeg|gif|webp)/i], // 匹配图片的正则表达式\n\n            // 监听 body 标签上的 tag 发生变化，如果设置为 true，那么，每次变化均触发首屏时间的自动计算。主要用于单页应用计算首屏\n            watchPerfStartChange: true,\n\n            // 延时执行上报\n            delayReport: 0,\n\n            domChangeList: [],\n\n            navigationStartChangeTag: ['data-perf-start', 'perf-start'],\n\n            // tag 变化防抖，200ms 以内的频繁变化不被计算\n            navigationStartChangeDebounceTime: 200,\n\n            domUpdateMutationObserver: null,\n\n            scriptLoadingMutationObserver: null,\n\n            // 用于拦截 jsonp 请求，js url 匹配该正则时\n            jsonpFilter: /callback=jsonp/,\n\n            reportTimeFrom: ''\n        }\n    },\n\n    getTime: function () {\n        return new Date().getTime();\n    },\n\n    mergeGlobal: function (defaultGlobal, privateGlobal) {\n        var key;\n        for (key in privateGlobal) {\n            defaultGlobal[key] = privateGlobal[key];\n        }\n\n        return defaultGlobal;\n    },\n\n    overrideRequest: function (_global, onStable) {\n        var _this = this;\n        var requestTimerStatusPool = {};\n\n        // 用于统计 js 请求（不含 jsonp）\n        var scriptRequestPool = {};\n\n        var hasAllReuestReturned = function () {\n            for (var key in _global.requestDetails) {\n                if (_global.requestDetails[key] && _global.requestDetails[key].status !== 'complete') {\n                    return false;\n                }\n            }\n\n            return true;\n        };\n\n        var isRequestTimerPoolEmpty = function () {\n            for (var key in requestTimerStatusPool) {\n                if (requestTimerStatusPool[key] !== 'stopped') {\n                    return false;\n                }\n            }\n\n            return true;\n        };\n\n        var shouldCatchThisRequest = function (url) {\n            // 默认抓取该请求到队列，认为其可能影响首屏\n            var shouldCatch = true;\n\n            if (_global.stopCatchingRequest) {\n                shouldCatch = false;\n            }\n\n            var sendTime = _this.getTime();\n\n            // 如果发送数据请求的时间点在时间窗口内，则认为该抓取该请求到队列，主要抓取串联型请求\n            for (var sectionIndex = 0; sectionIndex < _global.catchRequestTimeSections.length; sectionIndex++) {\n                var poolItem = _global.catchRequestTimeSections[sectionIndex];\n                if (sendTime >= poolItem[0] && sendTime <= poolItem[1]) {\n                    break;\n                }\n            }\n            if (_global.catchRequestTimeSections.length && sectionIndex === _global.catchRequestTimeSections.length) {\n                shouldCatch = false;\n            }\n\n            // 如果发送请求地址不符合白名单和黑名单规则。则认为不该抓取该请求到队列\n            for (var i = 0, len = _global.request.limitedIn.length; i < len; i++) {\n                if (!_global.request.limitedIn[i].test(url)) {\n                    shouldCatch = false;\n                }\n            }\n\n            for (var i = 0, len = _global.request.exclude.length; i < len; i++) {\n                if (_global.request.exclude[i].test(url)) {\n                    shouldCatch = false;\n                }\n            }\n\n            return shouldCatch;\n        }\n\n        var ensureRequestDetail = function (requestKey) {\n            if (!_global.requestDetails[requestKey]) {\n                _global.requestDetails[requestKey] = {\n                    status: '',\n                    completeTimeStamp: '',\n                    completeTime: '',\n                    type: ''\n                };\n            }\n        };\n\n        var onRequestSend = function (url, type) {\n            if (!_global.isFirstRequestSent) {\n                _global.isFirstRequestSent = true;\n            }\n\n            var requestKey = url + '>time:' + _this.getTime();\n            ensureRequestDetail(requestKey);\n\n            _global.requestDetails[requestKey].status = 'sent';\n            _global.requestDetails[requestKey].type = type;\n\n            requestTimerStatusPool[requestKey] = 'start';\n\n            return {\n                requestKey: requestKey\n            }\n        };\n\n        var afterRequestReturn = function (requestKey) {\n            //  当前时刻\n            var returnTime = _this.getTime();\n\n            ensureRequestDetail(requestKey);\n\n            // 标记这个请求完成\n            _global.requestDetails[requestKey].status = 'complete';\n            _global.requestDetails[requestKey].completeTimeStamp = returnTime;\n            _global.requestDetails[requestKey].completeTime = returnTime - _global.forcedNavStartTimeStamp;\n\n            // 从这个请求返回的时刻起，延续一段时间，该时间段内的请求也需要被监听\n            _global.catchRequestTimeSections.push([returnTime, returnTime + _global.renderTimeAfterGettingData]);\n\n            var renderDelayTimer = setTimeout(function () {\n                requestTimerStatusPool[requestKey] = 'stopped';\n                if (hasAllReuestReturned() && isRequestTimerPoolEmpty()) {\n                    onStable();\n                }\n                clearTimeout(renderDelayTimer);\n            }, _global.renderTimeAfterGettingData);\n        };\n\n        var overideXhr = function (onRequestSend, afterRequestReturn) {\n            var XhrProto = XMLHttpRequest.prototype;\n            var oldXhrSend = XhrProto.send;\n            XhrProto.send = function () {\n                if (shouldCatchThisRequest(this._http.url)) {\n                    var requestKey = onRequestSend(this._http.url, 'xhr').requestKey;\n\n                    var oldReadyCallback = this.onreadystatechange;\n                    this.onreadystatechange = function () {\n                        if (this.readyState === 4) {\n                            afterRequestReturn(requestKey);\n                        }\n\n                        if (oldReadyCallback && oldReadyCallback.apply) {\n                            oldReadyCallback.apply(this, arguments);\n                        }\n                    };\n                }\n\n                return oldXhrSend.apply(this, SLICE.call(arguments));\n            };\n        };\n        \n        var overrideFetch = function (onRequestSend, afterRequestReturn) {\n            if (window.fetch && typeof Promise === 'function') {\n                // ensure Promise exists. If not, skip cathing request\n                var oldFetch = window.fetch;\n                window.fetch = function () {\n                    var _this = this;\n                    var args = arguments;\n\n                    return new Promise(function (resolve, reject) {\n                        var url;\n                        var requestKey;\n\n                        if (typeof args[0] === 'string') {\n                            url = args[0];\n                        } else if (typeof args[0] === 'object') { // Request Object\n                            url = args[0].url;\n                        }\n\n                        // when failed to get fetch url, skip report\n                        if (url) {\n                            // console.warn('[auto-compute-first-screen-time] no url param found in \"fetch(...)\"');\n                            requestKey = onRequestSend(url, 'fetch').requestKey;\n                        }\n\n                        oldFetch.apply(_this, args).then(function (response) {\n                            if (requestKey) {\n                                afterRequestReturn(requestKey);\n                            }\n                            resolve(response);\n                        }).catch(function (err) {\n                            if (requestKey) {\n                                afterRequestReturn(requestKey);\n                            }\n                            reject(err);\n                        });\n                    })\n                };\n            }\n        };\n\n        var overrideJsonp = function (onRequestSend, afterRequestReturn) {\n                var requestMap = {};\n                var responseMap = {};\n\n                var getScriptSrc = function (node) {\n                    if (/script/i.test(node.tagName) && /^http/.test(node.src)) {\n                        return node.src;\n                    }\n                    return '';\n                };\n\n                var afterLoadOrErrorOrTimeout = function (requestKey) {\n                    if (!responseMap[requestKey]) {\n                        responseMap[requestKey] = true;\n                        afterRequestReturn(requestKey);\n                    }\n                }\n\n                var addLoadWatcher = function (node) {\n                    var src = getScriptSrc(node);\n\n                    if (!src) {\n                        return;\n                    }\n\n                    // filter jsonp script url\n                    if (!_global.jsonpFilter.test(src)) {\n                        return;\n                    }\n\n                    if (!requestMap[src]) {\n                        requestMap[src] = true;\n\n                        var requestKey = onRequestSend(src, 'jsonp').requestKey;\n\n                        // 超时时间为 3000\n                        var timeoutTimer = setTimeout(function () {\n                            afterLoadOrErrorOrTimeout(requestKey);\n                            clearTimeout(timeoutTimer);\n                        }, 3000);\n\n                        if (node.readyState) { // IE\n                            node.addEventListener('readystatechange', function () {\n                                if (script.readyState == 'loaded' || script.readyState == 'complete') {\n                                    afterLoadOrErrorOrTimeout(requestKey);\n                                    clearTimeout(timeoutTimer);\n                                }\n                            });\n                        }\n                        else { // Others\n                            node.addEventListener('load', function () {\n                                afterLoadOrErrorOrTimeout(requestKey);\n                                clearTimeout(timeoutTimer);\n                            });\n                            node.addEventListener('error', function () {\n                                afterLoadOrErrorOrTimeout(requestKey);\n                                clearTimeout(timeoutTimer);\n                            });\n                        }\n                    }\n\n                };\n\n                \n                var queryScriptNode = function(callback) {\n                    var scripts = document.getElementsByTagName('script');\n                    var scriptsArray = SLICE.call(scripts, 0);\n\n                    for (var i = 0, len = scriptsArray.length; i < len; i++) {\n                        callback(scriptsArray[i]);\n                    }\n                };\n\n                if (MutationObserver) {\n                    _global.scriptLoadingMutationObserver = new MutationObserver(function (mutations, observer) {\n                        mutations.forEach(function (mutation) {\n                            if (mutation.addedNodes) {\n                                mutation.addedNodes.forEach(function (addedNode) {\n                                    addLoadWatcher(addedNode);\n                                });\n                            }\n                        });\n                    });\n                    _global.scriptLoadingMutationObserver.observe(document.body, {\n                        attributes: false,\n                        childList: true,\n                        subtree: true\n                    });\n\n                    queryScriptNode(function (scriptNode) {\n                        addLoadWatcher(scriptNode);\n                    });\n                } else {\n                    _global.scriptLoadingMutationObserverMockTimer = setInterval(function () {\n                        queryScriptNode(function(scriptNode) {\n                            addLoadWatcher(scriptNode);\n                        });\n                    }, 200);\n\n                    queryScriptNode(function (scriptNode) {\n                        addLoadWatcher(scriptNode);\n                    });\n                }\n        };\n\n        // overide fetch first, then xhr, because fetch could be mocked by xhr\n        overrideFetch(onRequestSend, afterRequestReturn);\n\n        overideXhr(onRequestSend, afterRequestReturn);\n        \n        overrideJsonp(onRequestSend, afterRequestReturn);\n    },\n\n    stopCatchingRequest: function (_global) {\n        if (_global.scriptLoadingMutationObserverMockTimer) {\n            clearInterval(_global.scriptLoadingMutationObserverMockTimer);\n        }\n        if (_global.scriptLoadingMutationObserver) {\n            _global.scriptLoadingMutationObserver.disconnect();\n        }\n    },\n\n    mergeUserConfig: function (_global, userConfig) {\n        if (userConfig) {\n            for (var userConfigKey in userConfig) {\n                if (['watingTimeWhenDefineStaticPage', 'onReport', 'onStableStatusFound', 'renderTimeAfterGettingData', 'onAllXhrResolved', 'onNavigationStartChange', 'watchPerfStartChange', 'forcedNavStartTimeStamp', 'delayReport', 'navigationStartChangeTag', 'jsonpFilter'].indexOf(userConfigKey) !== -1) {\n                    _global[userConfigKey] = userConfig[userConfigKey];\n                }\n            }\n\n            var requestConfig = userConfig.request || userConfig.xhr;\n            if (requestConfig) {\n                if (requestConfig.limitedIn) {\n                    _global.request.limitedIn = _global.request.limitedIn.concat(requestConfig.limitedIn);\n                }\n                if (requestConfig.exclude) {\n                    _global.request.exclude = _global.request.exclude.concat(requestConfig.exclude);\n                }\n            }\n\n            if (userConfig.img) {\n                if (typeof userConfig.img === 'object' && typeof userConfig.img.test === 'function') {\n                    _global.img.push(userConfig.img);\n                } else {\n                    console.error('[auto-compute-first-screen-time] param \"img\" should be type RegExp');\n                }\n            }\n        }\n\n        // 不用全等，避免字符串和数字之间不相等的情况\n        _global._isUsingOriginalNavStart = _global.forcedNavStartTimeStamp == _global._originalNavStart;\n    },\n\n    testStaticPage: function (onStable, _global) {\n        var handler = function () {\n            acftGlobal.onloadFinished = true;\n\n            // 如果脚本运行完毕，延时一段时间后，再判断页面是否发出异步请求，如果页面还没有发出异步请求，则认为该时刻为稳定时刻，尝试上报\n            var timer = setTimeout(function () {\n                clearTimeout(timer);\n\n                if (!_global.isFirstRequestSent) {\n                    onStable();\n                }\n            }, _global.watingTimeWhenDefineStaticPage);\n        };\n\n        if (acftGlobal.onloadFinished) {\n            handler();\n        } else {\n            window.addEventListener('load', handler);\n        }\n    },\n\n    watchDomUpdate: function (_global) {\n        if (MutationObserver) {\n            _global.domUpdateMutationObserver = new MutationObserver(function () {\n                _global.domUpdateTimeStamp = new Date().getTime();\n                _global.domChangeList.unshift({\n                    timeStamp: _global.domUpdateTimeStamp,\n                    duration: _global.domUpdateTimeStamp - _global.forcedNavStartTimeStamp\n                });\n            });\n            _global.domUpdateMutationObserver.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        }\n    },\n    stopWatchDomUpdate: function (_global) {\n        if (_global.domUpdateMutationObserver) {\n            _global.domUpdateMutationObserver.disconnect();\n        }\n    },\n\n    onNavigationStartChange: function (_lanchGlobal, callback) {\n        if (_lanchGlobal.watchPerfStartChange && !acftGlobal.watchingNavStartChange) {\n            acftGlobal.watchingNavStartChange = true; // 一个页面，只允许一个观察者\n\n            var getTagValue = function (navigationStartChangeTag) {\n                var value;\n                for (var i = 0, len = navigationStartChangeTag.length; i < len; i++) {\n                    value = document.body.getAttribute(navigationStartChangeTag[i]);\n\n                    if (value) {\n                        return value;\n                    }\n                }\n\n                return '';\n            };\n\n            var hasChanged = function(pre, cur) {\n                // 当前有值，且和之前的值不同（之前的值可以为空），认为变化了\n                if (cur && cur != pre) {\n                    return true;\n                }\n\n                // 当前无值，但之前有值，认为变化了\n                if (!cur && pre) {\n                    return true;\n                }\n\n                return false;\n            }\n\n            var preTagValue;\n            var curTagValue;\n\n            var realChangeList = acftGlobal.navigationTagChangeMap.realChangeList;\n            var usedChangeList = acftGlobal.navigationTagChangeMap.usedChangeList;\n            var checkShouldRunCallback = function() {\n                var curTagValue = getTagValue(_lanchGlobal.navigationStartChangeTag);\n\n                if (hasChanged(preTagValue, curTagValue)) {\n                    var currentTimeStamp = new Date().getTime();\n\n                    var changeInfo = {\n                        preTagValue: preTagValue,\n                        curTagValue: curTagValue,\n                        value: curTagValue,\n                        timeStamp: currentTimeStamp,\n                        time: currentTimeStamp - _lanchGlobal._originalNavStart\n                    };\n\n                    // 记录真实的变化情况\n                    realChangeList.push(changeInfo);\n\n                    preTagValue = curTagValue;\n                    \n                    if (realChangeList.length === 1) { // 第 1 次变化，不触发 callback\n                        usedChangeList.push(changeInfo);\n                    } else { // 第 2 次和更多的变化\n                        var usedListLength = usedChangeList.length;\n                        var preUsedTime = usedChangeList[usedListLength - 1].timeStamp;\n\n                        // 防抖，如果在一段时间内触发了多次变化，只取初始变化的那一次\n                        if (currentTimeStamp - preUsedTime >= _lanchGlobal.navigationStartChangeDebounceTime) {\n                            usedChangeList.push(changeInfo);\n                            callback(changeInfo);\n                        }\n                    }\n                }\n            };\n\n            if (MutationObserver) {\n                var observer = new MutationObserver(function (mutations, observer) {\n                    mutations.forEach(function (mutation) {\n                        if (_lanchGlobal.navigationStartChangeTag.indexOf(mutation.attributeName) !== -1) {\n                            checkShouldRunCallback();\n                        }\n                    });\n                });\n                observer.observe(document.body, { \n                    attributes: true,\n                    childList: false,\n                    subtree: false\n                });\n            } else {\n                setInterval(checkShouldRunCallback, 250);\n            }\n        }\n    },\n\n    cycleGettingPerformaceTime: function (_global, firstScreenImages, callback) {\n        var maxFetchTimes = 50;\n        var fetchCount = 0;\n        var formattedFirstScreenImages = firstScreenImages.map(this.formateUrlByRemove);\n        var that = this;\n\n        var getPerformanceTime = function () {\n            var source = performance.getEntries();\n            var matchedLength = 0;\n            var i;\n            var len;\n\n            var firstScreenImagesDetail = []; // reset\n\n            // source 去重\n            var filteredSource = [];\n            var sourceMap = {};\n            for (i = 0, len = source.length; i < len; i++) {\n                var sourceItem = source[i];\n                var url = sourceItem.name;\n                if (!sourceMap[url]) {\n                    sourceMap[url] = true;\n                    filteredSource.push(sourceItem);\n                }\n            }\n\n            // 从 source 中找到图片加载信息\n            for (i = 0, len = filteredSource.length; i < len; i++) {\n                var sourceItem = filteredSource[i];\n                var imgUrl = sourceItem.name;\n                if (formattedFirstScreenImages.indexOf(that.formateUrlByRemove(imgUrl)) !== -1) {\n                    matchedLength++;\n\n                    var responseEnd = parseInt(sourceItem.responseEnd);\n                    var fetchStart = parseInt(sourceItem.fetchStart);\n                    firstScreenImagesDetail.push({\n                        src: imgUrl,\n                        responseEnd: responseEnd < 0 ? 0 : responseEnd,\n                        fetchStart: fetchStart < 0 ? 0 : fetchStart,\n                        from: 'performance'\n                    });\n                }\n            }\n\n            // 倒序\n            firstScreenImagesDetail.sort(function (a, b) {\n                return b.responseEnd - a.responseEnd;\n            });\n\n            if (matchedLength === firstScreenImages.length) {\n                clearInterval(timer);\n\n                callback({\n                    firstScreenTime: parseInt(firstScreenImagesDetail[0].responseEnd),\n                    firstScreenTimeStamp: parseInt(firstScreenImagesDetail[0].responseEnd) + _global._originalNavStart,\n                    firstScreenImagesDetail: firstScreenImagesDetail\n                });\n            }\n\n            fetchCount++;\n            if (fetchCount >= maxFetchTimes) {\n                clearInterval(timer);\n            }\n        };\n\n        // 轮询多次获取 performance 信息，直到 performance 信息能够展示首屏资源情况\n        var timer = setInterval(getPerformanceTime, 1000);\n\n        getPerformanceTime();\n    },\n    getByOnload: function (_global, firstScreenImages, callback, getFromPerformance) {\n        var afterLoadCount = 0;\n        var that = this;\n        var firstScreenImagesDetail = [];\n\n        var afterLoad = function (src, loadType) {\n            afterLoadCount++;\n\n            var now = new Date().getTime();\n\n            firstScreenImagesDetail.push({\n                src: src,\n                responseEnd: now - _global.forcedNavStartTimeStamp,\n                fetchStart: 'unkown',\n                type: loadType\n            });\n\n            if (afterLoadCount === firstScreenImages.length) {\n                // 倒序\n                firstScreenImagesDetail.sort(function (a, b) {\n                    return b.responseEnd - a.responseEnd;\n                });\n\n                callback({\n                    firstScreenTime: now - _global.forcedNavStartTimeStamp,\n                    firstScreenTimeStamp: now + _global._originalNavStart,\n                    firstScreenImagesDetail: firstScreenImagesDetail\n                });\n            }\n        };\n\n        var protocol = window.location.protocol;\n\n        var shouldGetFromPerformance = true;\n\n        var imgCount = 0;\n        firstScreenImages.forEach(function (src) {\n            var img = new Image();\n\n            img.src = that.formateUrlByAdd(src);\n\n            imgCount++;\n\n            if (img.complete) {\n                afterLoad(src, 'complete');\n\n                if (imgCount === firstScreenImages.length) {\n                    shouldGetFromPerformance = false;\n                }\n            } else {\n                shouldGetFromPerformance = false;\n                img.onload = img.onerror = function () {\n                    afterLoad(src, 'onload');\n                };\n            }\n        });\n\n        if (shouldGetFromPerformance) {\n            getFromPerformance();\n        }\n    }\n};\n\n\n//# sourceURL=webpack://autoComputeFirstScreenTime/./util.js?");

/***/ })

/******/ });
});